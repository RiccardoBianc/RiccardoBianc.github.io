abstracts:
  - keyword: "PhDThesis"
    abstract: Reasoning about programs and their correctness concerns, in the first place, their input/output behaviour. However, there are many important properties which are non-extensional, that is, allow to further classify programs. Among those, a significant class are the properties related to the resources needed to carry out the computation successfully. There are many possible views of what a “resource” is, e.g., space or time complexity; in this thesis, a resource is meant to be some external data, used in a program through an internal name (a variable), and resource-awareness means the ability to track, statically and/or at runtime, how these resources are used by the program. The aim of this thesis is to provide design guidelines and formal foundations to smoothly add resource-awareness to a programming language, mainly focusing on the object-oriented paradigm. This is a novelty, since in the literature resource-awareness has been studied in the context of functional languages.To achieve this goal, the key idea is to use annotations, called grades, which, intuitively, represent the availability of a resource. These annotations are elements of an algebraic structure called grade algebra, and both type system and reduction are given parametrically on an arbitrary grade algebra, modeling a particular kind of usages. We also investigate the possibility for to the programmer to define her/his grades. The thesis includes two chapters which achieve additional results, notably the application of the proposed approach to a functional language, a novel formulation of resource-aware semantics, and an application of grades to a challenging case, that is, to characterize sharing and immutability properties in the context of imperative languages.

  - keyword: "DBLP:journals/pacmpl/BianchiniDGZ23"
    abstract: We extend the semantics and type system of a lambda calculus equipped with common constructs to be resource-aware. That is, reduction is instrumented to keep track of the usage of resources, and the type system guarantees, besides standard soundness, that for well-typed programs there is a computation where no needed resource gets exhausted. The resource-aware extension is parametric on an arbitrary grade algebra, and does not require ad-hoc changes to the underlying language. To this end, the semantics needs to be formalized in big-step style; as a consequence, expressing and proving (resource-aware) soundness is challenging, and is achieved by applying recent techniques based on coinductive reasoning.  

  - keyword: "DBLP:conf/ecoop/BianchiniDGZ23"
    abstract: Resource-aware type systems statically approximate not only the expected result type of a program, but also the way external resources are used, e.g., how many times the value of a variable is needed. We extend the type system of Featherweight Java to be resource-aware, parametrically on an arbitrary grade algebra modeling a specific usage of resources. We prove that  this  type system is sound with respect to a resource-aware version of reduction,  that is, a well-typed program has a reduction sequence which does not get stuck due to resource consumption. Moreover, we show that the available grades can be heterogeneous, that is, obtained by combining grades of different kinds, via a minimal collection of homomorphisms  from one kind to another.  Finally, we show how grade algebras and homomorphisms can be specified as Java classes, so that grade annotations in types can be written in the language itself.

  - keyword: "DBLP:journals/pacmpl/BianchiniDGZS22"
    abstract: In type-and-coeffect systems, contexts are enriched by coeffects modeling how they are actually used, typically through annotations on single variables. Coeffects are computed bottom-up, combining, for each term, the coeffects of its subterms, through a fixed set of algebraic operators. We show that this principled approach can be adopted to track sharing in the imperative paradigm, that is, links among variables possibly introduced by the execution. This provides a significant example of non-structural coeffects, which cannot be computed by-variable, since the way a given variable is used can affect the coeffects of other variables. To illustrate the effectiveness of the approach, we enhance the type system tracking sharing to model a sophisticated set of features related to uniqueness and immutability. Thanks to the coeffect-based approach, we can express such features in a simple way and prove related properties with standard techniques.  

  - keyword: "DBLP:conf/ictcs/BianchiniDGZ22"
    abstract: We propose a Java-like calculus where declared variables can be annotated by coeffects specifying constraints on their use, such as linearity or privacy levels. Annotations are written in the language itself, as expressions of type Coeffect, a predefined class which can be extended by user-defined subclasses, modeling the coeffects desired for a specific application. We formalize the type system and prove subject reduction, which includes preservation of coeffects, and show several examples.

  - keyword: "DBLP:conf/coordination/BianchiniD21"
    abstract: Global types are at the core of communication based programming. They allow a high level specification of protocols involving many participants and enforce good safety and liveness properties, such as absence of deadlock, locked participants and orphan messages. In this paper, we describe an implementation of a novel formalism of global types for sessions with asynchronous communications in co-logic programming, where we use coinduction to properly handle the coinductive syntax of global types and processes. We also define a simple query language to write sessions and global types, providing primitives for type checking.

  - keyword: "DBLP:journals/scp/BianchiniD23"
    abstract: Global types are at the core of communication-based programming. They allow a high-level specification of protocols involving many participants and enforce good safety and liveness properties, such as deadlock freedom, and the absence of locked participants and orphan messages. The present software provides an implementation in co-logic programming of a novel formalism of global types for sessions with asynchronous communications, where we use coinduction to properly handle the coinductive syntax of global types and processes. It also offers a simple query language to write sessions and global types, providing primitives for type checking.
  
  - keyword: "DBLP:journals/tcs/BianchiniDGZ23"
    abstract: We propose a Java-like calculus where declared variables can be annotated by coeffects specifying constraints on their use, e.g., affinity or privacy levels. Such coeffects are heterogeneous, in the sense that different kinds of coeffects can be used in the same program; combining coeffects of different kinds leads to the trivial coeffect. We prove subject reduction, which includes preservation of coeffects, and show several examples. In a Java-like language, coeffects can be expressed in the language itself, as expressions of user-defined classes.
  
  - keyword: "DBLP:conf/vortex/Bianchini23"
    abstract: We show that resource-aware semantics, an execution model recently developed in the research community working on substructural type systems, can be naturally seen as a kind of monitored reduction.
  
  - keyword: "bianchini2025dontexhaustdontwaste"
    abstract: We extend the semantics and type system of a lambda calculus equipped with common constructs to be resource-aware. That is, the semantics keep tracks of the usage of resources, and is stuck, besides in case of type errors, if either a needed resource is exhausted, or a provided resource would be wasted. In such way, the type system guarantees, besides standard soundness, that for well-typed programs there is a computation where no resource gets either exhausted or wasted. The no-waste extension is parametric on an arbitrary grade algebra, modeling an arbitrary assortment of possible usages, and does not require ad-hoc changes to the underlying language. To this end, the semantics needs to be formalized in big-step style; as a consequence, expressing and proving (resource-aware) soundness is challenging, and is achieved by applying recent techniques based on coinductive reasoning.
  
  - keyword: "DBLP:journals/corr/abs-2302-07782"
    abstract: Resource-aware type systems statically approximate not only the expected result type of a program, but also the way external resources are used, e.g., how many times the value of a variable is needed. We extend the type system of Featherweight Java to be resource-aware, parametrically on an arbitrary grade algebra modeling a specific usage of resources. We prove that this type system is sound with respect to a resource-aware version of reduction, that is, a well-typed program has a reduction sequence which does not get stuck due to resource consumption. Moreover, we show that the available grades can be heterogeneous, that is, obtained by combining grades of different kinds, via a minimal collection of homomorphisms from one kind to another. Finally, we show how grade algebras and homomorphisms can be specified as Java classes, so that grade annotations in types can be written in the language itself.
  
  - keyword: "DBLP:journals/corr/abs-2209-07439"
    abstract: In type-and-coeffect systems, contexts are enriched by coeffects modeling how they are actually used, typically through annotations on single variables. Coeffects are computed bottom-up, combining, for each term, the coeffects of its subterms, through a fixed set of algebraic operators. We show that this principled approach can be adopted to track sharing in the imperative paradigm, that is, links among variables possibly introduced by the execution. This provides a significant example of non-structural coeffects, which cannot be computed by-variable, since the way a given variable is used can affect the coeffects of other variables. To illustrate the effectiveness of the approach, we enhance the type system tracking sharing to model a sophisticated set of features related to uniqueness and immutability. Thanks to the coeffect-based approach, we can express such features in a simple way and prove related properties with standard techniques.